"False"
} else {
paste(sort(chars_in_common), collapse=", ")
}
}
find_intersects(example1) # 1, 4, 13
find_intersects <- function(input) {
char_vec_list <- strsplit(input, ',\\s*')
chars_in_common <- Reduce(intersect, char_vec_list)
if (length(chars_in_common) == 0) {
"False"
} else {
paste(chars_in_common, collapse=", ")
}
}
find_intersects(example1) # 1, 4, 13
find_intersects(example2) # 1, 9, 10
find_intersects(example3) # FALSE
find_intersects(example4) # 10
531 %% 1
531 %% 10
531 %% 100
10^(c5:0)
10^c(5:0)
length(555)
digits(555)
nchar(555)
543 %/% 10^(nchar(543):0)
lapply(c(nchar(1543):0), function(x, y) { (y %% 10^x) %/% 10^(x-1) }, 1543)
lapply(c(nchar(1543):1), function(x, y) { (y %% 10^x) %/% 10^(x-1) }, 1543)
sapply(c(nchar(1543):1), function(x, y) { (y %% 10^x) %/% 10^(x-1) }, 1543)
# The function
largestSwap <- function(n) {
digits <- sapply(c(nchar(n):1), function(x, y) { (y %% 10^x) %/% 10^(x-1) }, n)
sorted_digits <- sort(digits)
digits == sorted_digits
}
#' My attempt at testing in R. There's a package for that, but it's
#' fairly involved to set up. This is a bit simpler
test_cases <- list(
list(input = 27, output = FALSE),
list(input = 43, output = TRUE),
list(input = 14, output = FALSE),
list(input = 53, output = TRUE),
list(input = 99, output = TRUE)
)
run_test <- function(case) {
largestSwap(case$input) == case$output
}
all(sapply(test_cases, run_test)) # TRUE
(sapply(test_cases, run_test)) # TRUE
# The function
largestSwap <- function(n) {
digits <- sapply(c(nchar(n):1), function(x, y) { (y %% 10^x) %/% 10^(x-1) }, n)
sorted_digits <- sort(digits)
digits == sorted_digits
}
n = 27
digits <- sapply(c(nchar(n):1), function(x, y) { (y %% 10^x) %/% 10^(x-1) }, n)
sorted_digits <- sort(digits)
digits == sorted_digits
all(digits == sorted_digits)
# The function
largestSwap <- function(n) {
digits <- sapply(c(nchar(n):1), function(x, y) { (y %% 10^x) %/% 10^(x-1) }, n)
sorted_digits <- sort(digits)
all(digits == sorted_digits)
}
#' My attempt at testing in R. There's a package for that, but it's
#' fairly involved to set up. This is a bit simpler
test_cases <- list(
list(input = 27, output = FALSE),
list(input = 43, output = TRUE),
list(input = 14, output = FALSE),
list(input = 53, output = TRUE),
list(input = 99, output = TRUE)
)
run_test <- function(case) {
largestSwap(case$input) == case$output
}
(sapply(test_cases, run_test)) # TRUE
?sort
sorted_digits <- sort(digits, decreasing = T)
all(digits == sorted_digits)
# The function
largestSwap <- function(n) {
digits <- sapply(c(nchar(n):1), function(x, y) { (y %% 10^x) %/% 10^(x-1) }, n)
sorted_digits <- sort(digits, decreasing = T)
all(digits == sorted_digits)
}
#' My attempt at testing in R. There's a package for that, but it's
#' fairly involved to set up. This is a bit simpler
test_cases <- list(
list(input = 27, output = FALSE),
list(input = 43, output = TRUE),
list(input = 14, output = FALSE),
list(input = 53, output = TRUE),
list(input = 99, output = TRUE)
)
run_test <- function(case) {
largestSwap(case$input) == case$output
}
(sapply(test_cases, run_test)) # TRUE
all(sapply(test_cases, run_test)) # TRUE
#' My attempt at testing in R. There's a package for that, but it's
#' fairly involved to set up. This is a bit simpler
test_cases <- list(
list(input = 27, output = FALSE),
list(input = 43, output = TRUE),
list(input = 14, output = FALSE),
list(input = 53, output = TRUE),
list(input = 99, output = TRUE),
list(input = 998, output = TRUE),
list(input = 899, output = FALSE),
list(input = 87654321, output = TRUE),
list(input = 87654312, output = FALSE),
list(input = 55555555555555555, output = TRUE),
)
run_test <- function(case) {
largestSwap(case$input) == case$output
}
#' My attempt at testing in R. There's a package for that, but it's
#' fairly involved to set up. This is a bit simpler
test_cases <- list(
list(input = 27, output = FALSE),
list(input = 43, output = TRUE),
list(input = 14, output = FALSE),
list(input = 53, output = TRUE),
list(input = 99, output = TRUE),
list(input = 998, output = TRUE),
list(input = 899, output = FALSE),
list(input = 87654321, output = TRUE),
list(input = 87654312, output = FALSE),
list(input = 55555555555555555, output = TRUE)
)
run_test <- function(case) {
largestSwap(case$input) == case$output
}
all(sapply(test_cases, run_test)) # TRUE
?grepl
args <- c('job_log.txt')
# Read in the file, line by line
file_contents <- readr::read_lines(args[1])
setwd('/home/eric/projects/midday_coding_challenges/20201013_gather_stats/')
args <- c('job_log.txt')
# Read in the file, line by line
file_contents <- readr::read_lines(args[1])
# Find the line with the start time, contains the word 'submitted'
submitted_time_line <- file_contents[sapply(file_contents, stringr::str_detect, 'submitted')]
?as.POSIXct
format <- '%b %d %H:%M:%S %Y'
pattern <- '\\w{3}\\s\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\s\\d{4}'
s <- submitted_time_line
format <- '%b %d %H:%M:%S %Y'
pattern <- '\\w{3}\\s\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\s\\d{4}'
datetime_string <- stringr::str_extract(s, pattern)
as.POSIXct(datetime_string, format=format)
pattern <- '\\d*\\.\\d*\\ssec'
# Find the lines with the relevant information
started_time_line <- file_contents[sapply(file_contents, stringr::str_detect, 'Started at')]
terminated_time_line <- file_contents[sapply(file_contents, stringr::str_detect, 'Terminated at')]
cpu_time_line <- file_contents[sapply(file_contents, stringr::str_detect, 'CPU time')]
max_memory_line <- file_contents[sapply(file_contents, stringr::str_detect, 'Max Memory')]
s <- cpu_time_line
pattern <- '\\d*\\.\\d*\\ssec'
cpu_time_string <- stringr::str_extract(s, pattern) %>%
stringr::str_remove('\\ssec$')
# Libraries --------------------------------------------------------------------
library(stringr)  # string operations
library(magrittr) # pipe operator
cpu_time_string <- stringr::str_extract(s, pattern) %>%
stringr::str_remove('\\ssec$')
as.numeric(cpu_time_string)
s <- max_memory_line
pattern <- '\\d+\\sMB'
string_rep <- stringr::str_extract(s, pattern) %>%
stringr::str_remove('\\sMB')
val <- as.numeric(string_rep)/100
paste0(val, 'G')
val <- as.numeric(string_rep)/1000
paste0(val, 'G')
efficiency <- function(start, end, cpu) {
(end - start)/cpu
}
submitted_time <- datetime_from_line(started_time_line)
terminated_time <- datetime_from_line(terminated_time_line)
cpu_time <- cpu_time_from_line(cpu_time_line)
# Functions --------------------------------------------------------------------
# DateTime format: Mon Oct 12 16:12:20 2020
datetime_from_line <- function(s) {
format <- '%b %d %H:%M:%S %Y'
pattern <- '\\w{3}\\s\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\s\\d{4}'
string_rep <- stringr::str_extract(s, pattern)
as.POSIXct(string_rep, format=format)
}
cpu_time_from_line <- function(s) {
pattern <- '\\d*\\.\\d*\\ssec'
string_rep <- stringr::str_extract(s, pattern) %>%
stringr::str_remove('\\ssec$')
as.numeric(string_rep)
}
max_memory_from_line <- function(s) {
pattern <- '\\d+\\sMB'
string_rep <- stringr::str_extract(s, pattern) %>%
stringr::str_remove('\\sMB')
val <- as.numeric(string_rep)/1000
paste0(val, 'G')
}
efficiency <- function(start, end, cpu) {
(end - start)/cpu
}
submitted_time <- datetime_from_line(started_time_line)
terminated_time <- datetime_from_line(terminated_time_line)
cpu_time <- cpu_time_from_line(cpu_time_line)
efficiency(terminated_time, submitted_time, cpu_time)
efficiency <- function(start, end, cpu) {
as.numeric(end - start)/cpu
}
efficiency(terminated_time, submitted_time, cpu_time)
efficiency(submitted_time, terminated_time, cpu_time)
submitted_time - terminated_time
terminated_time - submitted_time
(terminated_time - submitted_time)/2.4
2.4/(terminated_time - submitted_time)
2.4/as.numeric(terminated_time - submitted_time)
efficiency <- function(start, end, cpu) {
cpu/as.numeric(end - start)
}
efficiency(submitted_time, terminated_time, cpu_time)
# Libraries --------------------------------------------------------------------
library(stringr)  # string operations
library(magrittr) # pipe operator
library(glue)     # string interpolation
# Functions --------------------------------------------------------------------
# DateTime format: Mon Oct 12 16:12:20 2020
datetime_from_line <- function(s) {
format <- '%b %d %H:%M:%S %Y'
pattern <- '\\w{3}\\s\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\s\\d{4}'
string_rep <- stringr::str_extract(s, pattern)
as.POSIXct(string_rep, format=format)
}
cpu_time_from_line <- function(s) {
pattern <- '\\d*\\.\\d*\\ssec'
string_rep <- stringr::str_extract(s, pattern) %>%
stringr::str_remove('\\ssec$')
as.numeric(string_rep)
}
max_memory_from_line <- function(s) {
pattern <- '\\d+\\sMB'
string_rep <- stringr::str_extract(s, pattern) %>%
stringr::str_remove('\\sMB')
val <- as.numeric(string_rep)/1000
paste0(val, 'G')
}
line_by_tag <- function(tag, ss) {
line <- ss[sapply(ss, stringr::str_detect, tag)]
if (length(line) > 1) {
stop(glue('The tag ({tag}) did not identify a unique line.'))
}
line
}
efficiency <- function(start, end, cpu) {
cpu/as.numeric(end - start)
}
tags <- list('Started at', 'Terminated at', 'CPU time', 'Max Memory')
lapply(tags, line_by_tag, file_contents)
?mapply
line_by_tag(tags, file_contents)
tags <- list(started = 'Started at', terminated = 'Terminated at', cpu = 'CPU time', max_mem = 'Max Memory')
lapply(tags, line_by_tag, file_contents)
parse_funs <- list(started = datetime_from_line, terminated = datetime_from_line, cpu = cpu_time_from_line, max_mem = max_memory_from_line())
parse_funs <- list(started = datetime_from_line, terminated = datetime_from_line, cpu = cpu_time_from_line, max_mem = max_memory_from_line
mapply(parse_line_by_tag, parse_funs, tags, MoreArgs = list(ss=file_contents))
parse_line_by_tag <- function(parse_fun, tag, ss) {
line <- ss[sapply(ss, stringr::str_detect, tag)]
if (length(line) > 1) {
stop(glue('The tag ({tag}) did not identify a unique line.'))
}
parse_fun(line)
}
mapply(parse_line_by_tag, parse_funs, tags, MoreArgs = list(ss=file_contents))
tags <- list(started = 'Started at', terminated = 'Terminated at', cpu = 'CPU time', max_mem = 'Max Memory')
parse_funs <- list(started = datetime_from_line, terminated = datetime_from_line, cpu = cpu_time_from_line, max_mem = max_memory_from_line)
mapply(parse_line_by_tag, parse_funs, tags, MoreArgs = list(ss=file_contents))
mapply(parse_line_by_tag, parse_funs, tags, MoreArgs = list(ss=file_contents), SIMPLIFY = F)
?data.frame
operations_frame <- data.frame(
tags = c('Started at', 'Terminated at', 'CPU time', 'Max Memory'),
parse_funs = c(datetime_from_line, datetime_from_line, cpu_time_from_line, max_memory_from_line),
row.names = c('started', 'terminated', 'cpu', 'max_mem'),
stringsAsFactors = F
)
operations_frame <- data.frame(
tags = c('Started at', 'Terminated at', 'CPU time', 'Max Memory'),
parse_funs = list(datetime_from_line, datetime_from_line, cpu_time_from_line, max_memory_from_line),
row.names = c('started', 'terminated', 'cpu', 'max_mem'),
stringsAsFactors = F
)
library(tibble)   # better data frame
?tibble
operations_frame <- tibble(
tags = c('Started at', 'Terminated at', 'CPU time', 'Max Memory'),
parse_funs = list(datetime_from_line, datetime_from_line, cpu_time_from_line, max_memory_from_line),
.rows= c('started', 'terminated', 'cpu', 'max_mem')
)
operations_frame <- tibble(
tags = c('Started at', 'Terminated at', 'CPU time', 'Max Memory'),
parse_funs = list(datetime_from_line, datetime_from_line, cpu_time_from_line, max_memory_from_line),
row.names = c('started', 'terminated', 'cpu', 'max_mem')
)
View(operations_frame)
operations_frame <- tibble(
tags = c('Started at', 'Terminated at', 'CPU time', 'Max Memory'),
parse_funs = list(datetime_from_line, datetime_from_line, cpu_time_from_line, max_memory_from_line),
rownames = c('started', 'terminated', 'cpu', 'max_mem')
)
View(operations_frame)
operations_frame <- tibble(
tags = c('Started at', 'Terminated at', 'CPU time', 'Max Memory'),
parse_funs = list(datetime_from_line, datetime_from_line, cpu_time_from_line, max_memory_from_line),
rowname = c('started', 'terminated', 'cpu', 'max_mem')
)
View(operations_frame)
operations_frame <- tibble(
tags = c('Started at', 'Terminated at', 'CPU time', 'Max Memory'),
parse_funs = list(datetime_from_line, datetime_from_line, cpu_time_from_line, max_memory_from_line),
rowname = c('started', 'terminated', 'cpu', 'max_mem')
) %>%
column_to_rownames()
View(operations_frame)
operations_frame$tags[[started]]
operations_frame$tags[started]
operations_frame[tags, started]
operations_frame[started, tags]
operations_frame$tags['started']
View(operations_frame)
operations_frame$tags
operations_frame$tags[['started']]
operations_frame[['started']]
operations_frame['started']
operations_frame <- tibble(
value = c('started', 'terminated', 'cpu', 'max_mem'),
tag = c('Started at', 'Terminated at', 'CPU time', 'Max Memory'),
parse_funs = list(datetime_from_line, datetime_from_line, cpu_time_from_line, max_memory_from_line),
)
?bind_rows
??bind_rows
?rowbind
??rowbind
?rbind
rbind(tags, parse_funs)
cbind(tags, parse_funs)
cbind(tags, parse_funs)$started
cbind(tags, parse_funs)$parse_funs
tags <- list(
started    = 'Started at',
terminated = 'Terminated at',
cpu        = 'CPU time',
max_mem    = 'Max Memory'
)
parse_funs <- list(
started    = datetime_from_line,
terminated = datetime_from_line,
cpu        = cpu_time_from_line,
max_mem    = max_memory_from_line
)
mapply(parse_line_by_tag, parse_funs, tags, MoreArgs = list(ss=file_contents), SIMPLIFY = F)
parse_line_by_tag(datetime_from_line, '\\s+(Started at)\\w+\\.$', file_contents)
parse_line_by_tag(datetime_from_line, '\\s+Started at\\w+\\.$', file_contents)
parse_line_by_tag(datetime_from_line, '\\s+Started at\\w+\\.', file_contents)
parse_line_by_tag(datetime_from_line, '\\s+Started at[\\w\\d]+\\.', file_contents)
parse_line_by_tag(datetime_from_line, '\\s*Started at[\\w\\d]+\\.', file_contents)
parse_line_by_tag(datetime_from_line, 'Started at[\\w\\d]+\\.', file_contents)
parse_line_by_tag(datetime_from_line, 'Started at[\\w\\d]+', file_contents)
parse_line_by_tag(datetime_from_line, 'Started at', file_contents)
parse_line_by_tag(datetime_from_line, 'Started at[\\w\\d:]+', file_contents)
parse_line_by_tag(datetime_from_line, 'Started at[\\w\\d\\:]+', file_contents)
parse_line_by_tag(datetime_from_line, 'Started at[\\w\\d\\:\\s]+', file_contents)
parse_line_by_tag(datetime_from_line, 'Started at[\\w\\d\\:\\s]+\\.$', file_contents)
parse_line_by_tag(datetime_from_line, '(Started at)[\\w\\d\\:\\s]+\\.$', file_contents)
parse_line_by_tag(datetime_from_line, '\\s+(Started at)[\\w\\d\\:\\s]+\\.$', file_contents)
parse_line_by_tag(datetime_from_line, '^\\s+(Started at)[\\w\\d\\:\\s]+\\.$', file_contents)
parse_line_by_tag(datetime_from_line, '^\\s+(Started at)\\.*$', file_contents)
parse_line_by_tag(datetime_from_line, '\\s+(Started at)\\.*$', file_contents)
parse_line_by_tag(datetime_from_line, '^\\s+(Started at).*$', file_contents)
parse_line_by_tag(datetime_from_line, '^\\s+(Started at).*\\.$', file_contents)
args <- c('dummy_log.txt')
# Read in the file, line by line
file_contents <- readr::read_lines(args[1])
if (length(file_contents) == 0) {
stop('File contains no information.')
}
args <- c('job_log.txt')
if (length(file_contents) == 0) {
stop('File contains no information.')
}
args <- c('job_log.txt')
# Read in the file, line by line
file_contents <- readr::read_lines(args[1])
if (length(file_contents) == 0) {
stop('File contains no information.')
}
parse_results <- mapply(
parse_line_by_search_string,
parse_funs,
search_strings,
MoreArgs = list(ss=file_contents),
SIMPLIFY = F
)
# Functions --------------------------------------------------------------------
# DateTime format: Mon Oct 12 16:12:20 2020
datetime_from_line <- function(s) {
format <- '%b %d %H:%M:%S %Y'
pattern <- '\\w{3}\\s\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\s\\d{4}'
string_rep <- stringr::str_extract(s, pattern)
as.POSIXct(string_rep, format=format)
}
cpu_time_from_line <- function(s) {
pattern <- '\\d*\\.\\d*\\ssec'
string_rep <- stringr::str_extract(s, pattern) %>%
stringr::str_remove('\\ssec$')
as.numeric(string_rep)
}
max_memory_from_line <- function(s) {
pattern <- '\\d+\\sMB'
string_rep <- stringr::str_extract(s, pattern) %>%
stringr::str_remove('\\sMB')
val <- as.numeric(string_rep)/1000
paste0(val, 'G')
}
parse_line_by_search_string <- function(parse_fun, search_string, ss) {
line <- ss[sapply(ss, stringr::str_detect, search_string)]
if (length(line) > 1) {
stop(glue('The search_string ({search_string}) did not identify a unique line.'))
}
parse_fun(line)
}
walltime <- function(start, end) {
as.numeric(end - start)
}
efficiency <- function(start, end, cpu) {
cpu/walltime(start, end)
}
parse_results <- mapply(
parse_line_by_search_string,
parse_funs,
search_strings,
MoreArgs = list(ss=file_contents),
SIMPLIFY = F
)
# search_strings are strings that uniquely identify a line
# parse_funs are functions that extract the desired information from a line
search_strings <- list(
started    = '^\\s+(Started at).*\\.$',
terminated = '^\\s+(Terminated at).*\\.$',
cpu        = '^\\s+(CPU time).*\\.$',
max_mem    = '^\\s+(Max Memory).*\\MB$'
)
parse_funs <- list(
started    = datetime_from_line,
terminated = datetime_from_line,
cpu        = cpu_time_from_line,
max_mem    = max_memory_from_line
)
parse_results <- mapply(
parse_line_by_search_string,
parse_funs,
search_strings,
MoreArgs = list(ss=file_contents),
SIMPLIFY = F
)
View(parse_results)
list2env(parse_results) # makes the list elements available directly to parent environment
result <- with(
parse_results,
{
paste(
glue('Walltime: {walltime(started, terminated)}s'),
glue('CPU Time: {cpu}s'),
glue('Max Memory: {max_mem}G'),
glue('Efficiency: {efficiency(started, terminated, cpu)}')
)
}
)
result
cat(result)
result <- with(
parse_results,
{
paste(
glue('Walltime: {walltime(started, terminated)}s'),
glue('CPU Time: {cpu}s'),
glue('Max Memory: {max_mem}G'),
glue('Efficiency: {efficiency(started, terminated, cpu)}'),
sep = '/n'
)
}
)
cat(result)
result <- with(
parse_results,
{
paste(
glue('Walltime: {walltime(started, terminated)}s'),
glue('CPU Time: {cpu}s'),
glue('Max Memory: {max_mem}G'),
glue('Efficiency: {efficiency(started, terminated, cpu)}'),
sep = '\n'
)
}
)
cat(result)
