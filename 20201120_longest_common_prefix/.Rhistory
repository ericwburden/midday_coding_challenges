arr <- c("flower","flow","flight")
char_vecs <- strsplit(arr, '')
?mapply
unlist(char_vecs)
?do.call
char_vecs$FUN = '=='
do.call(mapply, char_vecs)
?Reduce
?mapply
char_vecs <- strsplit(arr, '')
char_vecs$FUN <- Reduce
char_vecs$MoreArgs <- list(f = '==')
do.call(mapply, char_vecs)
reduce_equal <- function(x) {
Reduce('==', x)
}
c('a', 'a', 'a')
xx <- c('a', 'a', 'a')
reduce_equal(xx)
xx[1] == x[2]
xx[1] == xx[2]
all_equal <- function(x) {
all(x==x[1])
}
all_equal(xx)
char_vecs <- strsplit(arr, '')
char_vecs$FUN <- all_equal
do.call(mapply, char_vecs)
all_equal <- function(...) {
x <- c(...)
all(x==x[1])
}
arr <- c("flower","flow","flight")
char_vecs <- strsplit(arr, '')
char_vecs$FUN <- all_equal
do.call(mapply, char_vecs)
?mapply
char_vecs <- strsplit(arr, '')
char_vecs$FUN <- all_equal
pre_indices <- do.call(mapply, char_vecs)
names(pre_indices[pre_indices])
paste(names(pre_indices[pre_indices]), collapse = '')
arr <- c("flower","dog","cat")
char_vecs <- strsplit(arr, '')
char_vecs$FUN <- all_equal
pre_indices <- do.call(mapply, char_vecs)
paste(names(pre_indices[pre_indices]), collapse = '')
all_equal(c(1, 2), c(3, 4))
all_equal(c(1, 2), c(1, 4))
all_equal(c(1, 2), c(1, 2))
#' Returns true if all passed arguments are equivalent
all_equal <- function(...) {
x <- c(...)
print(x == x[1])
all(x==x[1])
}
all_equal(c(1, 2), c(1, 2))
c(1, 2) == c(1, 2)
xx <- list(c(1, 2), c(1, 2))
xx
Reduce(unique, xx)
length(Reduce(unique, xx))
unique(xx)
?all.equal
all.equal(c(1, 2), c(1, 2))
?Map
xx
ll <- c(1:length(ll))
ll <- c(1:length(x))
ll <- c(1:length(xx))
ll
seq(length(xx))
seq(length(integer(0)))
seq(length(1))
list()
list() == list()
length(list()) == 0
#' Returns true if all passed arguments are equivalent
all_equal <- function(...) {
args <- list(...)
if (length(args) == 0) { stop('all_equal must be called with arguments') }
}
all_equal()
#' Returns true if all passed arguments are equivalent
all_equal <- function(...) {
args <- list(...)
if (length(args) == 0) { stop('all_equal must be called with arguments') }
length(unique(args)) == 1
}
all_equal('f', 'f', 'f')
all_equal(c(1, 2), c(1, 2))
all_equal(c(1, 2, 3), c(1, 2, 4))
arr <- c("flower","dog","cat")
char_vecs <- strsplit(arr, '')
char_vecs$FUN <- all_equal
pre_indices <- do.call(mapply, char_vecs)
paste(names(pre_indices[pre_indices]), collapse = '')
arr <- c("flower","flow","cat")
char_vecs <- strsplit(arr, '')
char_vecs$FUN <- all_equal
pre_indices <- do.call(mapply, char_vecs)
paste(names(pre_indices[pre_indices]), collapse = '')
arr <- c("flower","flow","flowered")
char_vecs <- strsplit(arr, '')
char_vecs$FUN <- all_equal
pre_indices <- do.call(mapply, char_vecs)
paste(names(pre_indices[pre_indices]), collapse = '')
typeof('flow')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings
longest_common_prefix <- function(...) {
args <- list(...)
if (!all(typeof(args) == 'character')) { stop('all arguments must be strings') }
}
longest_common_prefix('flow', 'flower')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings
longest_common_prefix <- function(...) {
args <- list(...)
print(typeof(args))
if (!all(typeof(args) == 'character')) { stop('all arguments must be strings') }
}
longest_common_prefix('flow', 'flower')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings
longest_common_prefix <- function(...) {
args <- list(...)
print(typeof(args))
if (!all(is.character(args))) { stop('all arguments must be strings') }
}
longest_common_prefix('flow', 'flower')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings
longest_common_prefix <- function(...) {
args <- list(...)
print(is.character(args))
if (!all(is.character(args))) { stop('all arguments must be strings') }
}
longest_common_prefix('flow', 'flower')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings
longest_common_prefix <- function(...) {
args <- list(...)
print(sapply(args, is.character))
if (!all(is.character(args))) { stop('all arguments must be strings') }
}
longest_common_prefix('flow', 'flower')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings
longest_common_prefix <- function(...) {
args <- list(...)
print(sapply(args, is.character))
if (!all(sapply(args, is.character))) { stop('all arguments must be strings') }
}
longest_common_prefix('flow', 'flower')
longest_common_prefix(c('flow', 'flowing'), 'flower')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings
longest_common_prefix <- function(...) {
args <- list(...)
if (!all(sapply(args, is.character))) { stop('all arguments must be strings') }
char_vecs <- strsplit(arr, '')
print(char_vecs)
}
longest_common_prefix(c('flow', 'flowing'), 'flower')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings
longest_common_prefix <- function(...) {
args <- list(...)
if (!all(sapply(args, is.character))) { stop('all arguments must be strings') }
char_vecs <- strsplit(args, '')
print(char_vecs)
}
longest_common_prefix(c('flow', 'flowing'), 'flower')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings
longest_common_prefix <- function(...) {
args <- list(...)
if (!all(sapply(args, is.character))) { stop('all arguments must be strings') }
char_vecs <- strsplit(unlist(args), '')
print(char_vecs)
}
longest_common_prefix(c('flow', 'flowing'), 'flower')
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings. Any vector or list arguments will be unpacked
#' to a single vector for comparison.
longest_common_prefix <- function(...) {
args <- list(...)
if (!all(sapply(unlist(args), is.character))) { stop('all arguments must be strings') }
char_vecs <- strsplit(unlist(args), '')
print(char_vecs)
}
longest_common_prefix(c('flow', 'flowing'), 'flower')
source('~/projects/midday_coding_challenges/20201120_longest_common_prefix/longest_common_prefix.R', echo=TRUE)
char_vecs$FUN <- NULL
lapply(char_vecs, '[[', c(1:max(lengths(char_vecs))))
lapply(char_vecs, '[', c(1:max(lengths(char_vecs))))
lapply(char_vecs, '[', c(1:min(lengths(char_vecs))))
?mapply
pre_indices
arr <- c("flower","flowar","flowered")
longest_common_prefix(arr)
which(pre_indices)
which(!pre_indices)
min(which(!pre_indices))
c(1, 2, 3)[1:0]
library(testthat)
arg1 <- c("flower","flow","flight")
arg2 <- "flattery"
longest_common_prefix(arg1, arg2)
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings. Any vector or list arguments will be unpacked
#' to a single vector for comparison.
longest_common_prefix <- function(...) {
args <- list(...)
# Error if passed a non-string
if (!all(sapply(unlist(args), is.character))) {
stop('all arguments must be strings')
}
#' Convert all arguments to a single list of vectors, where each vector
#' contains all the individual characters from each string
char_vecs <- strsplit(unlist(args), '')
#' Normalize all the vectors in the list to be the length of the shortest
#' string, only exists to keep `mapply()` from throwing a warning about
#' mismatched argument lengths
char_vecs <- lapply(char_vecs, '[', seq(min(lengths(char_vecs))))
print(char_vecs)
#' Attach the `all_equal` function to the char_vecs list, will be parsed by
#' do.call as an additional named argument to the `mapply` function
char_vecs$FUN <- all_equal
#' So, this passes all the items from `char_vecs` to `mapply` as individual
#' arguments. This is why `FUN` was attached to `char_vecs` as a list element.
#' The end result is that `all_equal()` will be called with the first element
#' of each character vector, then the second, then the third, etc. The
#' result of these repeated calls will be a named logical vector where the
#' values indicate which indices matched across vectors and the names
#' indicate the value at each index of the first vector
pre_indices <- do.call(mapply, char_vecs)
#' Get the index of the first `FALSE` value in `pre_indices`
first_false <- min(which(!pre_indices))
#' Collapse the names of the elements in `pre_indices` up to
#' (but not including) the first `FALSE` value, unless there are
#' no matches
if (first_false == 1) { "" } else {
paste(names(pre_indices[c(1:first_false-1)]), collapse = '')
}
}
longest_common_prefix(arg1, arg2)
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings. Any vector or list arguments will be unpacked
#' to a single vector for comparison.
longest_common_prefix <- function(...) {
args <- list(...)
# Error if passed a non-string
if (!all(sapply(unlist(args), is.character))) {
stop('all arguments must be strings')
}
#' Convert all arguments to a single list of vectors, where each vector
#' contains all the individual characters from each string
char_vecs <- strsplit(unlist(args), '')
#' Normalize all the vectors in the list to be the length of the shortest
#' string, only exists to keep `mapply()` from throwing a warning about
#' mismatched argument lengths
char_vecs <- lapply(char_vecs, '[', seq(min(lengths(char_vecs))))
#' Attach the `all_equal` function to the char_vecs list, will be parsed by
#' do.call as an additional named argument to the `mapply` function
char_vecs$FUN <- all_equal
#' So, this passes all the items from `char_vecs` to `mapply` as individual
#' arguments. This is why `FUN` was attached to `char_vecs` as a list element.
#' The end result is that `all_equal()` will be called with the first element
#' of each character vector, then the second, then the third, etc. The
#' result of these repeated calls will be a named logical vector where the
#' values indicate which indices matched across vectors and the names
#' indicate the value at each index of the first vector
pre_indices <- do.call(mapply, char_vecs)
#' Get the index of the first `FALSE` value in `pre_indices`
first_false <- min(which(!pre_indices))
#' Collapse the names of the elements in `pre_indices` up to
#' (but not including) the first `FALSE` value, unless there are
#' no matches
if (first_false == 1) { "" } else {
paste(names(pre_indices[c(1:first_false-1)]), collapse = '')
}
}
longest_common_prefix(arg1, arg2)
arg1 <- c("flower","flow","flight")
arg2 <- "flattery"
arg3 <- c("dog", "flyer", "flippant")
expect_equal(longest_common_prefix(arg1, arg2), "fl")
expect_equal(longest_common_prefix(arg2, arg3), "")
arg4 <- list("flashy", "flagrant")
expect_equal(longest_common_prefix(arg1, arg3, arg4), "fl")
expect_equal(longest_common_prefix(arg1, arg2, arg4), "fl")
expect_error(longest_common_prefix(1, 2, 3))
expect_error(longest_common_prefix('a', 'b', 3))
expect_error(longest_common_prefix(list(1, 2), 'test'))
expect_error(longest_common_prefix(c(1, 2), list('abc', 'def')))
?sappy
?sapply
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings. Any vector or list arguments will be unpacked
#' to a single vector for comparison.
longest_common_prefix <- function(...) {
args <- list(...)
# # Error if passed a non-string
# if (!all(sapply(unlist(args), is.character))) {
#   stop('all arguments must be strings')
# }
#' Convert all arguments to a single list of vectors, where each vector
#' contains all the individual characters from each string
char_vecs <- strsplit(unlist(args), '')
#' Normalize all the vectors in the list to be the length of the shortest
#' string, only exists to keep `mapply()` from throwing a warning about
#' mismatched argument lengths
char_vecs <- lapply(char_vecs, '[', seq(min(lengths(char_vecs))))
#' Attach the `all_equal` function to the char_vecs list, will be parsed by
#' do.call as an additional named argument to the `mapply` function
char_vecs$FUN <- all_equal
#' So, this passes all the items from `char_vecs` to `mapply` as individual
#' arguments. This is why `FUN` was attached to `char_vecs` as a list element.
#' The end result is that `all_equal()` will be called with the first element
#' of each character vector, then the second, then the third, etc. The
#' result of these repeated calls will be a named logical vector where the
#' values indicate which indices matched across vectors and the names
#' indicate the value at each index of the first vector
pre_indices <- do.call(mapply, char_vecs)
#' Get the index of the first `FALSE` value in `pre_indices`
first_false <- min(which(!pre_indices))
#' Collapse the names of the elements in `pre_indices` up to
#' (but not including) the first `FALSE` value, unless there are
#' no matches
if (first_false == 1) { "" } else {
paste(names(pre_indices[c(1:first_false-1)]), collapse = '')
}
}
longest_common_prefix(1, 2, 3)
?as.character
?lapply
#' Accepts any number of string arguments and returns the longest common
#' prefix among all strings. Any vector or list arguments will be unpacked
#' to a single vector for comparison.
longest_common_prefix <- function(...) {
args <- list(...)
#' Convert all arguments to characters
to_strings <- as.character(unlist(args))
#' Convert all arguments to a single list of vectors, where each vector
#' contains all the individual characters from each string
char_vecs <- strsplit(to_strings, '')
#' Normalize all the vectors in the list to be the length of the shortest
#' string, only exists to keep `mapply()` from throwing a warning about
#' mismatched argument lengths
char_vecs <- lapply(char_vecs, '[', seq(min(lengths(char_vecs))))
#' Attach the `all_equal` function to the char_vecs list, will be parsed by
#' do.call as an additional named argument to the `mapply` function
char_vecs$FUN <- all_equal
#' So, this passes all the items from `char_vecs` to `mapply` as individual
#' arguments. This is why `FUN` was attached to `char_vecs` as a list element.
#' The end result is that `all_equal()` will be called with the first element
#' of each character vector, then the second, then the third, etc. The
#' result of these repeated calls will be a named logical vector where the
#' values indicate which indices matched across vectors and the names
#' indicate the value at each index of the first vector
pre_indices <- do.call(mapply, char_vecs)
#' Get the index of the first `FALSE` value in `pre_indices`
first_false <- min(which(!pre_indices))
#' Collapse the names of the elements in `pre_indices` up to
#' (but not including) the first `FALSE` value, unless there are
#' no matches
if (first_false == 1) { "" } else {
paste(names(pre_indices[c(1:first_false-1)]), collapse = '')
}
}
longest_common_prefix(1, 2, 3)
expect_equal(longest_common_prefix("112","113","111"), "11")
expect_equal(longest_common_prefix(112, 113, 111), "11")
matrix(letters, nrow = 3)
m <- matrix(letters, nrow = 3)
longest_common_prefix(m)
m <- matrix(c("brown", 'brow', 'brother', 'bromine'), nrow = 2)
m
longest_common_prefix(m)
