typeof(c(1, 2, 3, 4))
typeof(c(1, 2, 3, 4)) == 'integer'
typeof(c(1, 2, 3, 4)) == 'numeric'
msg <- character(0)
c(msg, 'hello')
library(learnr)
library(testthat)
knitr::opts_chunk$set(echo = TRUE)
# Ensure arguments fit the given constraints. Added additional constraints for
# type-checking and length-checking
check_constraints <- function(candies, extra_candies) {
msg <- character(0)
if (!is.integer(candies)) {
msg <- c(msg, '`candies` must be an integer vector')
}
if (!is.integer(extra_candies)) {
msg <- c(msg, '`extra_candies` must be an integer vector')
}
if (length(extra_candies) > 1) {
msg <- c(msg, '`extra_candies` should be a 1-length vector')
}
if (length(candies) < 2 | length(candies) > 100) {
msg <- c(msg, '`candies` should contain between 2 and 100 integers')
}
if (any(candies < 1 | candies > 100)) {
msg <- c(msg, 'each value of `candies` should be between 1 and 100')
}
if (extra_candies < 1 | extra_candies > 50) {
msg <- c(msg, '`extra_candies` should be between 1 and 50')
}
if (length(msg) > 0) {
stop(cat(msg, sep = '\n'))
}
}
gimme_some_candy <- function(candies, extra_candies) {
check_constraints(candies, extra_candies)
max_candies <- max(candies)  # Current maximum number of candies
# Add the extra candies to each child and check to see if it's at least
# equal to the prior maximum
(candies + extra_candies) >= max_candies
}
gimme_some_candy(c('2, 3, 5, 1, 3'), 3)
# Ensure arguments fit the given constraints. Added additional constraints for
# type-checking and length-checking
check_constraints <- function(candies, extra_candies) {
msg <- character(0)
if (!is.integer(candies)) {
msg <- c(msg, '`candies` must be an integer vector')
}
if (!is.integer(extra_candies)) {
msg <- c(msg, '`extra_candies` must be an integer vector')
}
if (length(extra_candies) > 1) {
msg <- c(msg, '`extra_candies` should be a 1-length vector')
}
if (length(candies) < 2 | length(candies) > 100) {
msg <- c(msg, '`candies` should contain between 2 and 100 integers')
}
if (any(candies < 1 | candies > 100)) {
msg <- c(msg, 'each value of `candies` should be between 1 and 100')
}
if (extra_candies < 1 | extra_candies > 50) {
msg <- c(msg, '`extra_candies` should be between 1 and 50')
}
if (length(msg) > 0) {
stop(paste(msg, sep = '\n'))
}
}
gimme_some_candy <- function(candies, extra_candies) {
check_constraints(candies, extra_candies)
max_candies <- max(candies)  # Current maximum number of candies
# Add the extra candies to each child and check to see if it's at least
# equal to the prior maximum
(candies + extra_candies) >= max_candies
}
gimme_some_candy(c('2, 3, 5, 1, 3'), 3)
# Ensure arguments fit the given constraints. Added additional constraints for
# type-checking and length-checking
check_constraints <- function(candies, extra_candies) {
msg <- character(0)
if (!is.integer(candies)) {
msg <- c(msg, '`candies` must be an integer vector')
}
if (!is.integer(extra_candies)) {
msg <- c(msg, '`extra_candies` must be an integer vector')
}
if (length(extra_candies) > 1) {
msg <- c(msg, '`extra_candies` should be a 1-length vector')
}
if (length(candies) < 2 | length(candies) > 100) {
msg <- c(msg, '`candies` should contain between 2 and 100 integers')
}
if (any(candies < 1 | candies > 100)) {
msg <- c(msg, 'each value of `candies` should be between 1 and 100')
}
if (extra_candies < 1 | extra_candies > 50) {
msg <- c(msg, '`extra_candies` should be between 1 and 50')
}
if (length(msg) > 0) {
stop(paste(msg, sep = '; '))
}
}
gimme_some_candy <- function(candies, extra_candies) {
check_constraints(candies, extra_candies)
max_candies <- max(candies)  # Current maximum number of candies
# Add the extra candies to each child and check to see if it's at least
# equal to the prior maximum
(candies + extra_candies) >= max_candies
}
gimme_some_candy(c('2, 3, 5, 1, 3'), 3)
# Ensure arguments fit the given constraints. Added additional constraints for
# type-checking and length-checking
check_constraints <- function(candies, extra_candies) {
msg <- character(0)
if (!is.integer(candies)) {
msg <- c(msg, '`candies` must be an integer vector')
}
if (!is.integer(extra_candies)) {
msg <- c(msg, '`extra_candies` must be an integer vector')
}
if (length(extra_candies) > 1) {
msg <- c(msg, '`extra_candies` should be a 1-length vector')
}
if (length(candies) < 2 | length(candies) > 100) {
msg <- c(msg, '`candies` should contain between 2 and 100 integers')
}
if (any(candies < 1 | candies > 100)) {
msg <- c(msg, 'each value of `candies` should be between 1 and 100')
}
if (extra_candies < 1 | extra_candies > 50) {
msg <- c(msg, '`extra_candies` should be between 1 and 50')
}
if (length(msg) > 0) {
stop(paste(msg, collapse = '\n'))
}
}
gimme_some_candy <- function(candies, extra_candies) {
check_constraints(candies, extra_candies)
max_candies <- max(candies)  # Current maximum number of candies
# Add the extra candies to each child and check to see if it's at least
# equal to the prior maximum
(candies + extra_candies) >= max_candies
}
gimme_some_candy(c('2, 3, 5, 1, 3'), 3)
# Ensure arguments fit the given constraints. Added additional constraints for
# type-checking and length-checking
check_constraints <- function(candies, extra_candies) {
msg <- character(0)
if (!is.integer(candies)) {
msg <- c(msg, '`candies` must be an integer vector')
}
if (!is.integer(extra_candies)) {
msg <- c(msg, '`extra_candies` must be an integer vector')
}
if (length(extra_candies) > 1) {
msg <- c(msg, '`extra_candies` should be a 1-length vector')
}
if (length(candies) < 2 | length(candies) > 100) {
msg <- c(msg, '`candies` should contain between 2 and 100 integers')
}
if (any(candies < 1 | candies > 100)) {
msg <- c(msg, 'each value of `candies` should be between 1 and 100')
}
if (extra_candies < 1 | extra_candies > 50) {
msg <- c(msg, '`extra_candies` should be between 1 and 50')
}
if (length(msg) > 0) {
stop(paste(msg, collapse = '; '))
}
}
gimme_some_candy <- function(candies, extra_candies) {
check_constraints(candies, extra_candies)
max_candies <- max(candies)  # Current maximum number of candies
# Add the extra candies to each child and check to see if it's at least
# equal to the prior maximum
(candies + extra_candies) >= max_candies
}
gimme_some_candy(c('2, 3, 5, 1, 3'), 3)
is.integer(3)
?is.integer
1 %% 1
10 %% 1
10.5 %% 1
# Check for whole (integer) numbers
is.whole <- function(n) {
(n %% 1) == 0
}
# Ensure arguments fit the given constraints. Added additional constraints for
# type-checking and length-checking
check_constraints <- function(candies, extra_candies) {
msg <- character(0)
if (!is.whole(candies)) {
msg <- c(msg, '`candies` must be an integer vector')
}
if (!is.whole(extra_candies)) {
msg <- c(msg, '`extra_candies` must be an integer vector')
}
if (length(extra_candies) > 1) {
msg <- c(msg, '`extra_candies` should be a 1-length vector')
}
if (length(candies) < 2 | length(candies) > 100) {
msg <- c(msg, '`candies` should contain between 2 and 100 integers')
}
if (any(candies < 1 | candies > 100)) {
msg <- c(msg, 'each value of `candies` should be between 1 and 100')
}
if (extra_candies < 1 | extra_candies > 50) {
msg <- c(msg, '`extra_candies` should be between 1 and 50')
}
if (length(msg) > 0) {
stop(paste(msg, collapse = '; '))
}
}
gimme_some_candy <- function(candies, extra_candies) {
check_constraints(candies, extra_candies)
max_candies <- max(candies)  # Current maximum number of candies
# Add the extra candies to each child and check to see if it's at least
# equal to the prior maximum
(candies + extra_candies) >= max_candies
}
gimme_some_candy(c('2, 3, 5, 1, 3'), 3)
# Check for whole (integer) numbers
is.whole <- function(n) {
if (is.numeric(n)) { (n %% 1) == 0 } else { F }
}
# Ensure arguments fit the given constraints. Added additional constraints for
# type-checking and length-checking
check_constraints <- function(candies, extra_candies) {
msg <- character(0)
if (!is.whole(candies)) {
msg <- c(msg, '`candies` must be an integer vector')
}
if (!is.whole(extra_candies)) {
msg <- c(msg, '`extra_candies` must be an integer vector')
}
if (length(extra_candies) > 1) {
msg <- c(msg, '`extra_candies` should be a 1-length vector')
}
if (length(candies) < 2 | length(candies) > 100) {
msg <- c(msg, '`candies` should contain between 2 and 100 integers')
}
if (any(candies < 1 | candies > 100)) {
msg <- c(msg, 'each value of `candies` should be between 1 and 100')
}
if (extra_candies < 1 | extra_candies > 50) {
msg <- c(msg, '`extra_candies` should be between 1 and 50')
}
if (length(msg) > 0) {
stop(paste(msg, collapse = '; '))
}
}
gimme_some_candy <- function(candies, extra_candies) {
check_constraints(candies, extra_candies)
max_candies <- max(candies)  # Current maximum number of candies
# Add the extra candies to each child and check to see if it's at least
# equal to the prior maximum
(candies + extra_candies) >= max_candies
}
gimme_some_candy(c('2, 3, 5, 1, 3'), 3)
# Check for whole (integer) numbers
is.whole <- function(n) {
if (is.numeric(n)) { (n %% 1) == 0 } else { F }
}
# Ensure arguments fit the given constraints. Added additional constraints for
# type-checking and length-checking
check_constraints <- function(candies, extra_candies) {
msg <- character(0)
if (!is.whole(candies)) {
msg <- c(msg, '`candies` must be an integer vector')
}
if (!is.whole(extra_candies)) {
msg <- c(msg, '`extra_candies` must be an integer vector')
}
if (length(extra_candies) > 1) {
msg <- c(msg, '`extra_candies` should be a 1-length vector')
}
if (length(candies) < 2 | length(candies) > 100) {
msg <- c(msg, '`candies` should contain between 2 and 100 integers')
}
if (is.whole(candies) & any(candies < 1 | candies > 100)) {
msg <- c(msg, 'each value of `candies` should be between 1 and 100')
}
if (is.whole(extra_candies) & extra_candies < 1 | extra_candies > 50) {
msg <- c(msg, '`extra_candies` should be between 1 and 50')
}
if (length(msg) > 0) {
stop(paste(msg, collapse = '; '))
}
}
gimme_some_candy <- function(candies, extra_candies) {
check_constraints(candies, extra_candies)
max_candies <- max(candies)  # Current maximum number of candies
# Add the extra candies to each child and check to see if it's at least
# equal to the prior maximum
(candies + extra_candies) >= max_candies
}
gimme_some_candy(c('2, 3, 5, 1, 3'), 3)
expect_error(gimme_some_candy(c('a'), 3), '`candies` must be an integer vector')
test_result <- test_that("`gimme_some_candy returns expected errors`", {
expect_error(gimme_some_candy(c('a'), 3), '`candies` must be an integer vector')
expect_error(gimme_some_candy(c(1, 2), '3'), '`extra_candies` must be an integer vector')
expect_error(gimme_some_candy(c(1, 2), c(1, 2)), '`extra_candies` should be a 1-length vector')
expect_error(gimme_some_candy(1, 3), '`candies` should contain between 2 and 100 elements')
expect_error(gimme_some_candy(rep(1, 102), 3), '`candies` should contain between 2 and 100 elements')
expect_error(gimme_some_candy(c(1, 102), 3), 'each value of `candies` should be between 1 and 100')
expect_error(gimme_some_candy(c(1, -5), 3), 'each value of `candies` should be between 1 and 100')
expect_error(gimme_some_candy(c(3, 7, 9), 0), '`extra_candies` should be between 1 and 50')
expect_error(gimme_some_candy(c(3, 7, 9), 100), '`extra_candies` should be between 1 and 50')
})
# Check for whole (integer) numbers
is.whole <- function(n) {
if (is.numeric(n)) { (n %% 1) == 0 } else { F }
}
# Ensure arguments fit the given constraints. Added additional constraints for
# type-checking and length-checking
check_constraints <- function(candies, extra_candies) {
msg <- character(0)
if (!is.whole(candies)) {
msg <- c(msg, '`candies` must be an integer vector')
}
if (!is.whole(extra_candies)) {
msg <- c(msg, '`extra_candies` must be an integer vector')
}
if (length(extra_candies) > 1) {
msg <- c(msg, '`extra_candies` should be a 1-length vector')
}
if (length(candies) < 2 | length(candies) > 100) {
msg <- c(msg, '`candies` should contain between 2 and 100 elements')
}
if (is.whole(candies) & any(candies < 1 | candies > 100)) {
msg <- c(msg, 'each value of `candies` should be between 1 and 100')
}
if (is.whole(extra_candies) & extra_candies < 1 | extra_candies > 50) {
msg <- c(msg, '`extra_candies` should be between 1 and 50')
}
if (length(msg) > 0) {
stop(paste(msg, collapse = '; '))
}
}
gimme_some_candy <- function(candies, extra_candies) {
check_constraints(candies, extra_candies)
max_candies <- max(candies)  # Current maximum number of candies
# Add the extra candies to each child and check to see if it's at least
# equal to the prior maximum
(candies + extra_candies) >= max_candies
}
test_result <- test_that("`gimme_some_candy returns expected errors`", {
expect_error(gimme_some_candy(c('a'), 3), '`candies` must be an integer vector')
expect_error(gimme_some_candy(c(1, 2), '3'), '`extra_candies` must be an integer vector')
expect_error(gimme_some_candy(c(1, 2), c(1, 2)), '`extra_candies` should be a 1-length vector')
expect_error(gimme_some_candy(1, 3), '`candies` should contain between 2 and 100 elements')
expect_error(gimme_some_candy(rep(1, 102), 3), '`candies` should contain between 2 and 100 elements')
expect_error(gimme_some_candy(c(1, 102), 3), 'each value of `candies` should be between 1 and 100')
expect_error(gimme_some_candy(c(1, -5), 3), 'each value of `candies` should be between 1 and 100')
expect_error(gimme_some_candy(c(3, 7, 9), 0), '`extra_candies` should be between 1 and 50')
expect_error(gimme_some_candy(c(3, 7, 9), 100), '`extra_candies` should be between 1 and 50')
})
load("~/projects/midday_coding_challenges/20201124_gimme_some_candy/.RData")
